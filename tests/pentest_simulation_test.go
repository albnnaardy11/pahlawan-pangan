package tests

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/albnnaardy11/pahlawan-pangan/internal/auth/domain"
	"github.com/albnnaardy11/pahlawan-pangan/internal/auth/usecase"
	"github.com/albnnaardy11/pahlawan-pangan/internal/outbox"
	"github.com/alicebob/miniredis/v2"
	"github.com/redis/go-redis/v9"
)

// PenTest Simulation: Testing Argon2id, JWT Blacklist, and Security Layers
func TestSecurityPenetration(t *testing.T) {
	fmt.Println("\nüõ°Ô∏è STARTING PENETRATION TEST SIMULATION...")

	// Setup Clean Environment
	s := miniredis.RunT(t)
	redisClient := redis.NewClient(&redis.Options{Addr: s.Addr()})
	
	repo := &mockUserRepo{}
	authUC := usecase.NewAuthUsecase(repo, redisClient, nil, time.Second)

	// --- ATTACK VECTOR 1: PASSWORD CRACKING ---
	t.Run("Argon2id Robustness Test", func(t *testing.T) {
		fmt.Println("üëâ Testing Password Hashing Security...")
		password := "Pahlawan123!"
		
		start := time.Now()
		hashed, _ := usecase.HashPassword(password)
		duration := time.Since(start)
		
		fmt.Printf("   [Argon2id] Hashing took %v (Slow by design to kill brute-force)\n", duration)
		
		match, _ := usecase.ComparePassword(password, hashed)
		if !match {
			t.Error("Auth logic failed: password should match")
		}
		
		// Attempt with wrong password
		fakeMatch, _ := usecase.ComparePassword("WrongPass", hashed)
		if fakeMatch {
			t.Error("Security Breach: Wrong password allowed")
		}
		fmt.Println("   ‚úÖ RESULT: Password cracking via brute force is structurally blocked by CPU-hard Argon2id.")
	})

	// --- ATTACK VECTOR 2: SESSION HIJACKING / REPLAY ---
	t.Run("JWT Blacklist (Force Logout) Test", func(t *testing.T) {
		fmt.Println("üëâ Testing Token Revocation (Ghost Session Attack)...")
		
		// Prepare a valid hash and user for the test
		validHashed, _ := usecase.HashPassword("pass")
		repo.validHash = validHashed
		repo.user = &domain.User{ID: "U001", Email: "test@ngo.org", Role: domain.RoleNGO}

		loginRes, err := authUC.Login(context.Background(), "test@ngo.org", "pass")
		if err != nil {
			t.Fatalf("Login failed: %v", err)
		}
		token := loginRes.Token
		
		// 1. Initial Access
		user, err := authUC.ValidateToken(context.Background(), token)
		if err != nil || user == nil {
			t.Fatalf("Initial token should be valid but got error: %v", err)
		}
		fmt.Println("   [Session] User logged in successfully.")

		// 2. Perform Logout (Simulated Force Logout from Session Manager)
		fmt.Println("   [Attack] Executing Force Logout (Blacklisting Token in Redis)...")
		_ = authUC.Logout(context.Background(), token)

		// 3. Attempt Access with Revoked Token
		userAfter, errAfter := authUC.ValidateToken(context.Background(), token)
		if errAfter == nil || userAfter != nil {
			t.Error("SECURITY BREACH: Token still valid after logout!")
		} else {
			fmt.Printf("   ‚úÖ RESULT: Blacklist caught the token. Access Denied: %v\n", errAfter)
		}
	})

	fmt.Println("üõ°Ô∏è PENETRATION TEST COMPLETED: SYSTEM SECURE.")
}

type mockUserRepo struct {
	user      *domain.User
	validHash string
}

func (m *mockUserRepo) Create(ctx context.Context, user *domain.User) error { return nil }
func (m *mockUserRepo) GetByEmail(ctx context.Context, email string) (*domain.User, error) {
	// Mock successful login check
	return &domain.User{
		ID:           "U001",
		Email:        email,
		PasswordHash: m.validHash,
	}, nil
}
func (m *mockUserRepo) GetByID(ctx context.Context, id string) (*domain.User, error) { return m.user, nil }
func (m *mockUserRepo) Update(ctx context.Context, user *domain.User) error   { return nil }

// Implementing missing interface methods
func (m *mockUserRepo) GetByIDForUpdate(ctx context.Context, id string) (*domain.User, error) {
	return m.user, nil
}
func (m *mockUserRepo) SaveAudit(ctx context.Context, event *domain.AccountEvent) error { return nil }
func (m *mockUserRepo) SaveOutbox(ctx context.Context, event *outbox.OutboxEvent) error { return nil }
func (m *mockUserRepo) WithTransaction(ctx context.Context, fn func(domain.UserRepository) error) error {
	return fn(m)
}
